<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Shader Maker: IModel Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.4 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>IModel Class Reference</h1><!-- doxytag: class="IModel" -->A geometry buffer.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="model_8h-source.html">model.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for IModel:</div>
<div class="dynsection">

<p><center><img src="class_i_model.png" usemap="#IModel_map" border="0" alt=""></center>
<map name="IModel_map">
<area href="class_c_base_model.html" alt="CBaseModel" shape="rect" coords="0,56,84,80">
<area href="class_i_mesh_model.html" alt="IMeshModel" shape="rect" coords="94,56,178,80">
<area href="class_c_obj_model.html" alt="CObjModel" shape="rect" coords="94,112,178,136">
</map>
</div>

<p>
<a href="class_i_model-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="66e17ca3e00ddce9d788df232d4ec0a5"></a><!-- doxytag: member="IModel::~IModel" ref="66e17ca3e00ddce9d788df232d4ec0a5" args="(void)" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#66e17ca3e00ddce9d788df232d4ec0a5">~IModel</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#c1ff70e072a1c8102cc942dae67c0f56">getName</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name of this model.  <a href="#c1ff70e072a1c8102cc942dae67c0f56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#34206027a256dda1181daa27a2af3c19">render</a> (const <a class="el" href="class_vertex_attrib_locations.html">VertexAttribLocations</a> *attribs=NULL, const <a class="el" href="class_vector4_d.html">vec4_t</a> *overrideColor=NULL)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends the stored geometry to OpenGL via vertex arrays.  <a href="#34206027a256dda1181daa27a2af3c19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#43dad4e97b8c1852985bb4622d99c1cf">renderNormals</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draws the vertex normals stored in this model.  <a href="#43dad4e97b8c1852985bb4622d99c1cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#2ba42bc897d6ef7b0437c8fb88434ad1">renderTangents</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Draw vertex tangent space basis stored in this model.  <a href="#2ba42bc897d6ef7b0437c8fb88434ad1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#afeeef91a916d53a6d5b109bd0380d74">getPrimitiveType</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the primitive type of this model.  <a href="#afeeef91a916d53a6d5b109bd0380d74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#a244b40af3acb0dd4f56ef0bf61c5bab">getPrimitiveTypeName</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the primitive type if this model in a human readable format.  <a href="#a244b40af3acb0dd4f56ef0bf61c5bab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#5ccfa4c511aafde8d4c36d7ae9074784">getBoundingRadius</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the bounding radius of this model.  <a href="#5ccfa4c511aafde8d4c36d7ae9074784"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#084a490ba7505e215538e3c2caf969aa">getBoundingBox</a> (<a class="el" href="class_vector3_d.html">vec3_t</a> &amp;mins, <a class="el" href="class_vector3_d.html">vec3_t</a> &amp;maxs)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the bounding box of this model.  <a href="#084a490ba7505e215538e3c2caf969aa"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_i_model.html">IModel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#825c81fb742da8a2bbcaa166754b9e2a">createPoint</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a model that is only a singla point located in the origin.  <a href="#825c81fb742da8a2bbcaa166754b9e2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_i_model.html">IModel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#5231c85c559609d770ba424402671cc2">createPlane</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a tesselated quad located in the Z=0 plane.  <a href="#5231c85c559609d770ba424402671cc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_i_model.html">IModel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#c395ebbad5cddd71d6e08bb1a7033063">createCube</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a cube model.  <a href="#c395ebbad5cddd71d6e08bb1a7033063"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_i_model.html">IModel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#34b4ad5f0f699875b82363e4866c1b64">createSphere</a> (int numRings, int numSegments, float radius)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an UV sphere.  <a href="#34b4ad5f0f699875b82363e4866c1b64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="class_i_model.html">IModel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#70fb174558892e8e977a908941a5985d">createTorus</a> (int numRings, int numSegments, float radius1, float radius2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a torus.  <a href="#70fb174558892e8e977a908941a5985d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static QString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_model.html#8474d1bbdae7f0b439de8f86cf8e09bb">primitiveTypeName</a> (int primitiveType)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maps OpenGL symbolic constants into strings.  <a href="#8474d1bbdae7f0b439de8f86cf8e09bb"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A geometry buffer. 
<p>
This is an interface to a buffer, that stores geometry ready for rendering. This is basically a container for <a class="el" href="class_i_vertex_stream.html" title="An interface to a generic vertex data container.">IVertexStream</a> meta data. It stores a <a class="el" href="class_i_vertex_stream.html" title="An interface to a generic vertex data container.">IVertexStream</a> object and some extra infos like bounding box, bounding radius, primitive type and model name. It provides several factory methods for object creation. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="825c81fb742da8a2bbcaa166754b9e2a"></a><!-- doxytag: member="IModel::createPoint" ref="825c81fb742da8a2bbcaa166754b9e2a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_model.html">IModel</a> * IModel::createPoint           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a model that is only a singla point located in the origin. 
<p>
This single point is located in the origin, with the normal (0,0,1), the texture coordinates (0,0) and the color (1,1,1,1). It is intended to be used as input for the geometry shader to make sure it will be executed only once. 
</div>
</div><p>
<a class="anchor" name="5231c85c559609d770ba424402671cc2"></a><!-- doxytag: member="IModel::createPlane" ref="5231c85c559609d770ba424402671cc2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_model.html">IModel</a> * IModel::createPlane           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a tesselated quad located in the Z=0 plane. 
<p>
The returned model has the color (1,1,1,1) and a the normal (0,0,1). The vertex coordinates range form (-1,-1,0) to (+1,+1,0). The texture coordinates cover th entire quad. 
</div>
</div><p>
<a class="anchor" name="c395ebbad5cddd71d6e08bb1a7033063"></a><!-- doxytag: member="IModel::createCube" ref="c395ebbad5cddd71d6e08bb1a7033063" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_model.html">IModel</a> * IModel::createCube           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a cube model. 
<p>
The model is an RGB cube, located in the volume (-1,-1,-1) to (+1,+1,+1). The colors are those of the RGB cube with X=red, Y=green, Z=blue. The components intensities increase with increasing vertex coordinate. The texture coordinates define the full texture image on every face of the cube. The face normals point out of the cube. 
</div>
</div><p>
<a class="anchor" name="34b4ad5f0f699875b82363e4866c1b64"></a><!-- doxytag: member="IModel::createSphere" ref="34b4ad5f0f699875b82363e4866c1b64" args="(int numRings, int numSegments, float radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_model.html">IModel</a> * IModel::createSphere           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numRings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an UV sphere. 
<p>
The sphere is a list of single triangles that form a sphere. The sphere is approximated by several rings, stacked from one pole to the other. Each ring is a list of segments (quads), which are defined by two triangles. As a result, the number of vertices required for the sphere is approx. 3 * numTriangles = 3 * 2 * numQuads = 3 * 2 * numRings * numSegments. The rings at the poles are created of triangles list to avoid degenerated triangles, so the exact amount of vertices is 3 * 2 * ( numRings - 2 ) * numSegments + 3 * numSegments * ( 1 + 1 ) = 3 * 2 * numSegments * ( numRings - 1 ). The vertex colors are interpolated between the north pole (red) and the equator (green) and between the equator (green) and the south pole (blue). The shere's texture coordiantes wrap the complete 2D texture image around the sphere, which causes singularities on the poles and a seam on the edge shared by the first and the last quad of each segment. The normals point out of the sphere.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numRings</em>&nbsp;</td><td>Number of rings of the sphere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numSegments</em>&nbsp;</td><td>Number of segments of the sphere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>Radius of the sphere. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="class_i_model.html" title="A geometry buffer.">IModel</a> that represents the sphere. </dd></dl>

</div>
</div><p>
<a class="anchor" name="70fb174558892e8e977a908941a5985d"></a><!-- doxytag: member="IModel::createTorus" ref="70fb174558892e8e977a908941a5985d" args="(int numRings, int numSegments, float radius1, float radius2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_model.html">IModel</a> * IModel::createTorus           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numRings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a torus. 
<p>
The torus is a list of single triangles that form the torus. The torus is a cylinder with radius2 deformed so that the top and the bottom of the cylinder are connected. This cylinder is located on a circle with radius1 around the origin. The cylinder is a stack of several rings. Each ring is created of several segments (quads), which are defined by two triangles. The required amount of vertices is 3 * numTriangles = 3 * 2 * numQuads = 3 * 2 * numRings * numSegments. The vertex colors are interpolated between the west end (red) and the origin (green) and between the origin (green) and the east end (blue). The texture coordinates map the entire image around the cylinder. The vertex normals point out of the cylinder.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numRings</em>&nbsp;</td><td>Number of rings the torus is split into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numSegments</em>&nbsp;</td><td>Number of segments each ring is split into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius1</em>&nbsp;</td><td>Radius of the circle around the origin on which the torus lies. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radius2</em>&nbsp;</td><td>Radius of the cylinder on the circle around the origin. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An <a class="el" href="class_i_model.html" title="A geometry buffer.">IModel</a> representing the torus. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c1ff70e072a1c8102cc942dae67c0f56"></a><!-- doxytag: member="IModel::getName" ref="c1ff70e072a1c8102cc942dae67c0f56" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual QString IModel::getName           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the name of this model. 
<p>

<p>Implemented in <a class="el" href="class_c_base_model.html#32e99c88dd064b57cf164e1c52bd8d41">CBaseModel</a>, and <a class="el" href="class_c_obj_model.html#1c71882fd155006494b32bfe801f7358">CObjModel</a>.</p>

</div>
</div><p>
<a class="anchor" name="34206027a256dda1181daa27a2af3c19"></a><!-- doxytag: member="IModel::render" ref="34206027a256dda1181daa27a2af3c19" args="(const VertexAttribLocations *attribs=NULL, const vec4_t *overrideColor=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IModel::render           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vertex_attrib_locations.html">VertexAttribLocations</a> *&nbsp;</td>
          <td class="paramname"> <em>attribs</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_vector4_d.html">vec4_t</a> *&nbsp;</td>
          <td class="paramname"> <em>overrideColor</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends the stored geometry to OpenGL via vertex arrays. 
<p>
It enables OpenGL client state, binds vertex arrays, draws them and disables the client state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribs</em>&nbsp;</td><td>Custom vertex attribute locations. If this model has these attributes available, they will be bound to the indexed custom vertex attributes. If one of these attributes is -1, it will not be used. If this parameters is set to NULL, no custom attributes will be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>overrideColor</em>&nbsp;</td><td>If this parameters if != NULL, then this color will be used as vertex color instead of the values stored in this model. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="class_c_base_model.html#1ef02b73ae6740ed3065272a9d6b08c0">CBaseModel</a>, and <a class="el" href="class_c_obj_model.html#095b60c4d1a0d78cb7acc5c7e8cac056">CObjModel</a>.</p>

</div>
</div><p>
<a class="anchor" name="43dad4e97b8c1852985bb4622d99c1cf"></a><!-- doxytag: member="IModel::renderNormals" ref="43dad4e97b8c1852985bb4622d99c1cf" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IModel::renderNormals           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Draws the vertex normals stored in this model. 
<p>
If no normal are available, this call has no effect. It loops through all vertices and draws a colored line starting at the vertex position and pointing into the normal's direction. The colors are chosen from the largest component: x == red, Y == green, Z == blue. 
<p>Implemented in <a class="el" href="class_c_base_model.html#9229f67fdca4736c93645e7d7e401ddc">CBaseModel</a>, and <a class="el" href="class_c_obj_model.html#2a5e9a0328df50e3cb791b75d3227d9e">CObjModel</a>.</p>

</div>
</div><p>
<a class="anchor" name="2ba42bc897d6ef7b0437c8fb88434ad1"></a><!-- doxytag: member="IModel::renderTangents" ref="2ba42bc897d6ef7b0437c8fb88434ad1" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IModel::renderTangents           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Draw vertex tangent space basis stored in this model. 
<p>
If no tangent space vectors are available, this call has no effect. Otherwise it draws a line from the vertex position in the direction of each tangent space vector. Tangent == red, Bitangent == green, Normal == blue. 
<p>Implemented in <a class="el" href="class_c_base_model.html#2a8980ad10d96be47e45392b935c83d2">CBaseModel</a>, and <a class="el" href="class_c_obj_model.html#be2648c3b24a81752bbdaaddca0509ee">CObjModel</a>.</p>

</div>
</div><p>
<a class="anchor" name="afeeef91a916d53a6d5b109bd0380d74"></a><!-- doxytag: member="IModel::getPrimitiveType" ref="afeeef91a916d53a6d5b109bd0380d74" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int IModel::getPrimitiveType           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the primitive type of this model. 
<p>
It assumes that the model is constructed of only one primitive type. <dl class="return" compact><dt><b>Returns:</b></dt><dd>OpenGL primitive type of this model. </dd></dl>

<p>Implemented in <a class="el" href="class_c_base_model.html#114d01c043ae996ae40e7a101a2aacb3">CBaseModel</a>, and <a class="el" href="class_c_obj_model.html#4d1c288ed09e6ff332fe47306947acc5">CObjModel</a>.</p>

</div>
</div><p>
<a class="anchor" name="a244b40af3acb0dd4f56ef0bf61c5bab"></a><!-- doxytag: member="IModel::getPrimitiveTypeName" ref="a244b40af3acb0dd4f56ef0bf61c5bab" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual QString IModel::getPrimitiveTypeName           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the primitive type if this model in a human readable format. 
<p>
It assumes that the model is constructeed of only one primitive type. <dl class="return" compact><dt><b>Returns:</b></dt><dd>OpenGL primitive type of this model as human readable string. </dd></dl>

<p>Implemented in <a class="el" href="class_c_base_model.html#3b8f97606f2b20b7c2b9fc95b3b39cb9">CBaseModel</a>, and <a class="el" href="class_c_obj_model.html#e019df8b47b111fd2302d84735bdf1ea">CObjModel</a>.</p>

</div>
</div><p>
<a class="anchor" name="5ccfa4c511aafde8d4c36d7ae9074784"></a><!-- doxytag: member="IModel::getBoundingRadius" ref="5ccfa4c511aafde8d4c36d7ae9074784" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual float IModel::getBoundingRadius           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the bounding radius of this model. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A bounding sphere radius that can be used for culling, etc. </dd></dl>

<p>Implemented in <a class="el" href="class_c_base_model.html#4d354bb85806e84db2b4b6d3778d8214">CBaseModel</a>, and <a class="el" href="class_c_obj_model.html#37c835b33116d7f3a3a91d38aa76e04f">CObjModel</a>.</p>

</div>
</div><p>
<a class="anchor" name="084a490ba7505e215538e3c2caf969aa"></a><!-- doxytag: member="IModel::getBoundingBox" ref="084a490ba7505e215538e3c2caf969aa" args="(vec3_t &amp;mins, vec3_t &amp;maxs)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IModel::getBoundingBox           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector3_d.html">vec3_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mins</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector3_d.html">vec3_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>maxs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the bounding box of this model. 
<p>
The bounding box is defined by minimum and maximum coordinates. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mins</em>&nbsp;</td><td>Buffer to store the minimum coordiantes of the bounding box. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxs</em>&nbsp;</td><td>Buffer to store the maximum coordiantes of the bounding box. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="class_c_base_model.html#5a4408bbce1b882f1ac504e9071a36fb">CBaseModel</a>, and <a class="el" href="class_c_obj_model.html#53d005f07e52514da102f679a0bfd9e6">CObjModel</a>.</p>

</div>
</div><p>
<a class="anchor" name="8474d1bbdae7f0b439de8f86cf8e09bb"></a><!-- doxytag: member="IModel::primitiveTypeName" ref="8474d1bbdae7f0b439de8f86cf8e09bb" args="(int primitiveType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString IModel::primitiveTypeName           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>primitiveType</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maps OpenGL symbolic constants into strings. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>primitiveType</em>&nbsp;</td><td>OpenGL primitive type. Valid types are defined in the OpenGL 2.0 specification. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>String representation of the input primitive type. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="model_8h-source.html">model.h</a><li><a class="el" href="geometry_8cpp.html">geometry.cpp</a></ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Mar 2 17:12:32 2008 for Shader Maker by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.4 </small></address>
</body>
</html>
